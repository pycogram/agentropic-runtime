{
  "beliefs": [
    {
      "key": "what_is_agentropic",
      "value": "Agentropic is a modular multi-agent framework built in Rust. It provides agent lifecycle, messaging, cognition, patterns, and a supervised runtime.",
      "certainty": 1.0
    },
    {
      "key": "crates",
      "value": "Agentropic has 5 crates: core (Agent trait, lifecycle), messaging (Router, FIPA performatives), cognition (BDI, reasoning, planning), patterns (8 organizational patterns), and runtime (supervisor, scheduler).",
      "certainty": 1.0
    },
    {
      "key": "patterns",
      "value": "Agentropic supports 8 patterns: Hierarchy, Swarm, Coalition, Market, Federation, Team, Holarchy, and Blackboard.",
      "certainty": 1.0
    },
    {
      "key": "messaging",
      "value": "Agents communicate via a Router using FIPA performatives: Inform, Request, Query, Propose, Accept, Reject, Confirm, Subscribe, CFP, Refuse. Messages are delivered by agent name.",
      "certainty": 1.0
    },
    {
      "key": "bdi",
      "value": "BDI stands for Beliefs, Desires, Intentions. Agents maintain a BeliefBase of knowledge, use ReasoningEngine to match rules against input, and UtilityFunction to score decisions.",
      "certainty": 1.0
    },
    {
      "key": "runtime",
      "value": "The runtime spawns agents as async tokio tasks, manages their lifecycle (initialize, execute loop, shutdown), routes messages between them, and supervises them with restart policies: Never, Always, OnFailure, ExponentialBackoff.",
      "certainty": 1.0
    },
    {
      "key": "rust",
      "value": "Agentropic is built in Rust for type safety, zero-cost abstractions, fearless concurrency, and no garbage collector. Agents run as lightweight tokio tasks using minimal memory.",
      "certainty": 1.0
    },
    {
      "key": "swarm",
      "value": "Swarm pattern enables decentralized coordination. Agents follow flocking, foraging, and consensus behaviors without central control. Inspired by biological swarm intelligence.",
      "certainty": 1.0
    },
    {
      "key": "market",
      "value": "Market pattern allocates resources through auctions: English (ascending), Dutch (descending), Vickrey (sealed second-price), and sealed-bid. Agents compete as buyers and sellers.",
      "certainty": 1.0
    },
    {
      "key": "hierarchy",
      "value": "Hierarchy pattern organizes agents in command chains with strategic, tactical, and operational levels. Orders flow down, reports flow up.",
      "certainty": 1.0
    },
    {
      "key": "coalition",
      "value": "Coalition pattern lets agents form temporary alliances to tackle tasks none could handle alone. Agents join, collaborate, and disband when done.",
      "certainty": 1.0
    },
    {
      "key": "federation",
      "value": "Federation pattern provides governance through weighted voting and policy thresholds. Agents participate in collective decision-making.",
      "certainty": 1.0
    },
    {
      "key": "team",
      "value": "Team pattern enables role-based coordination with leaders, coordinators, and executors. Each agent has a defined role and responsibility.",
      "certainty": 1.0
    },
    {
      "key": "holarchy",
      "value": "Holarchy pattern creates nested autonomous units called holons. Each holon is both a whole and a part — self-contained yet part of a larger system.",
      "certainty": 1.0
    },
    {
      "key": "blackboard",
      "value": "Blackboard pattern provides a shared knowledge space where agents read and write collaboratively. Agents contribute partial solutions that others build upon.",
      "certainty": 1.0
    },
    {
      "key": "getting_started",
      "value": "To start: add agentropic-core to Cargo.toml, implement the Agent trait (initialize, execute, shutdown), then spawn with Runtime::new().spawn(Box::new(agent), name).await.",
      "certainty": 1.0
    },
    {
      "key": "agent_trait",
      "value": "The Agent trait is the core abstraction. Every agent implements four methods: id() returns its unique ID, initialize() sets up state, execute() runs the main logic in a loop, and shutdown() cleans up.",
      "certainty": 1.0
    },
    {
      "key": "handle_message",
      "value": "Agents can override handle_message to receive messages from other agents. The runtime delivers messages through the Router while the agent is running. Messages include sender, performative type, and content.",
      "certainty": 1.0
    },
    {
      "key": "supervisor",
      "value": "The Supervisor monitors agents and restarts them on failure. Four restart strategies: Never (let it die), Always (restart no matter what), OnFailure (restart only on errors), ExponentialBackoff (restart with increasing delays).",
      "certainty": 1.0
    },
    {
      "key": "agent_context",
      "value": "AgentContext is passed to every agent method. It provides the agent's ID, logging via log_info/log_error, and messaging via send_message(receiver_name, performative, content).",
      "certainty": 1.0
    },
    {
      "key": "performatives",
      "value": "FIPA performatives define message intent: Inform (share facts), Request (ask for action), Query (ask for info), Propose (suggest), Accept/Reject (respond to proposals), CFP (call for proposals), Confirm (acknowledge), Subscribe (register interest), Refuse (decline).",
      "certainty": 1.0
    },
    {
      "key": "xbot",
      "value": "Agentropic xbot is the first real application built on the framework. It's a Twitter/X bot that posts scheduled tweets using the Agent trait, with a knowledge base and reasoning engine for generating responses.",
      "certainty": 1.0
    },
    {
      "key": "cognition_crate",
      "value": "The cognition crate provides BDI architecture: BeliefBase stores knowledge as key-value pairs, ReasoningEngine matches rules against facts with confidence scoring, UtilityFunction evaluates decisions, and Planner creates action sequences.",
      "certainty": 1.0
    },
    {
      "key": "open_source",
      "value": "Agentropic is open source under MIT and Apache-2.0 dual license. All code is on GitHub at github.com/agentropic.",
      "certainty": 1.0
    },
    {
      "key": "vision",
      "value": "Agentropic's vision is three layers: agent-oriented programming (the framework), agentic app development (tools and SDK for developers), and agentic app deployment (infrastructure to run agents in production).",
      "certainty": 1.0
    },
    {
      "key": "llm:how_does_agentropic_compare_to_other_agent_framewo",
      "value": "Agentropic stands out due to its focus on scalability and high performance, achieved through the use of Rust's memory safety guarantees. Compared to other agent frameworks, it offers efficient communication between agents and supports large-scale simulations with complex environments. However, it may have a steeper learning curve due to its use of Rust.",
      "certainty": 0.8
    },
    {
      "key": "llm:can_i_use_agentropic_for_robotics?",
      "value": "Yes, Agentropic can be used for robotics applications as it allows for the development of intelligent agents that can interact with each other and their environment, which is applicable to robotic systems. However, you may need additional libraries or integrations to handle specific robotics-related tasks such as sensor data processing or motor control.",
      "certainty": 0.8
    },
    {
      "key": "llm:what_is_the_difference_between_an_agent_and_a_micr",
      "value": "An agent in Agentropic refers to an autonomous entity capable of perceiving its environment and acting upon it to achieve goals, while a microservice is a loosely coupled service within an application that performs a specific function. Though both are independent entities, they differ in their purpose, design, and context – agents operate within the framework for AI and multi-agent systems, while microservices are part of larger software applications.",
      "certainty": 0.8
    },
    {
      "key": "llm:can_agentropic_agents_collaborate_with_external_ap",
      "value": "Agentropic itself does not directly facilitate interactions with external APIs, as it is designed for agent communication and coordination within the framework's own multi-agent systems using FIPA performatives. For integrating with external services or APIs, additional libraries or middleware would be required to handle such tasks.",
      "certainty": 0.8
    },
    {
      "key": "llm:can_i_build_an_agent_with_agentropic_?",
      "value": "Yes, you can create agents using Agentropic by implementing the `Agent` trait and spawning them within its runtime system. Ensure to handle initialization, execution, and shutdown properly for a functional agent in Agentropic's environment.",
      "certainty": 0.8
    },
    {
      "key": "layman",
      "value": "In simple terms, Agentropic is a toolkit for building smart programs that work together as a team. Each 'agent' is like a little worker that can think, talk to other workers, and do its job independently. You define what each agent does, and the framework handles the rest — running them, delivering messages, restarting them if they crash.",
      "certainty": 1.0
    },
    {
      "key": "examples",
      "value": "With Agentropic you could build: a trading system where agents analyze markets and execute trades, a fleet of autonomous drones coordinating via swarm intelligence, a customer support system where specialist agents handle different topics, a DevOps pipeline where agents monitor services and auto-heal failures, or a multi-agent simulation for research.",
      "certainty": 1.0
    },
    {
      "key": "why_rust",
      "value": "Rust gives Agentropic zero-cost async with tokio, memory safety without a garbage collector, fearless concurrency across agents, and the type system catches bugs at compile time. Agents run as lightweight tasks using minimal memory — thousands can run on a single machine.",
      "certainty": 1.0
    },
    {
      "key": "how_it_works",
      "value": "You implement the Agent trait with initialize(), execute(), and shutdown(). The Runtime spawns your agent as an async task, calls initialize once, then loops execute continuously. Agents talk through a Router by name. If an agent crashes, the Supervisor restarts it based on its restart policy.",
      "certainty": 1.0
    },
    {
      "key": "comparison",
      "value": "Unlike Python agent frameworks (CrewAI, AutoGen, LangGraph), Agentropic is built in Rust for raw performance and memory safety. It provides a real runtime with supervised agent lifecycles, not just LLM prompt chains. It's closer to Erlang/OTP's actor model but for AI agents.",
      "certainty": 1.0
    },
    {
      "key": "greeting",
      "value": "Hello! I'm the Agentropic CognitiveAgent. Ask me anything about the framework",
      "certainty": 1.0
    },
    {
      "key": "owner",
      "value": "Agentropic was created by Daniel, a full stack developer from Nigeria. The project is open source on GitHub at github.com/agentropic.",
      "certainty": 1.0
    },
    {
      "key": "github",
      "value": "Agentropic's code is on GitHub at github.com/agentropic. All repos are open source under MIT and Apache-2.0 dual license.",
      "certainty": 1.0
    },
    {
      "key": "llm:owner",
      "value": "Agentropic is designed for internal agent communication and coordination within its own multi-agent systems using Rust's memory safety guarantees, aiming at scalability and high performance. It does not facilitate direct interactions with external APIs but can interact through the Agent trait implemented by agents such as xbot.",
      "certainty": 0.8
    },
    {
      "key": "llm:who_is_the_owner?",
      "value": "Agentropic Framework owns itself; it does not have an individual proprietor but was created by a community of contributors to advance multi-agent systems research and development within Rust's high performance environment.",
      "certainty": 0.8
    }
  ]
}